<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- saved from url=(0049)http://ivr.webzone.ru/articles/autocorr/index.htm -->
<html lang="ru"><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1251">


<meta name="author" content="Иван Рощин">
<meta name="description" content="Рассказ о создании программы для
автоисправления орфографических ошибок и опечаток в текстовых файлах и о
работе с ней.">
<meta name="keywords" content="программа,утилита,исправление,ошибки,опечатки,
текст">

<title>Без ошибок и опечаток</title>

<style type="text/css">
<!--
body {background: white; color: black; padding: 7px 1.2em}
a[href] {text-decoration: underline}
a:link {color: blue}
a:visited {color: #9999cc}
a[href]:hover {background: yellow}
p {text-align: justify; text-indent: 2em; margin-top: 0; margin-bottom: 0}
.up {margin-top: 1em}
.ms {text-indent: 0}
.f {text-indent: 0; text-align: left}
h1 {text-align: center}
ul,ol,li {text-align: justify}
caption {font-style: italic}
p.f+p,p+div,div+p,div+div {margin-top: 1em}
table.c {border-collapse: collapse}
table.c,table.c th,table.c td {border: 1px solid black}
.g {background: silver}
.g1 {border: 0; padding: .2em}
a.g2:visited {color: black}
a.g2 {padding: .2em; line-height: 1.6em; border: 1px outset silver;
text-decoration: none}
a.g3:visited {color: black}
ul.mini-ul {margin-top: 0; padding-left: 3em}
div.list {padding-right: 1em; border: 1px solid silver}
div.list>ol {padding-left: 2em}
div.list>ol>li+li {margin-top: 1em}
div.letters {padding-left: 1.1em}
div.letter {margin-top: 1em; text-indent: -1.1em}
div.letter * {text-indent: 0}
-->
</style>
<script type="text/javascript">try {
window.AG_onLoad = function(func) { if (window.addEventListener) { window.addEventListener('DOMContentLoaded', func); } };
window.AG_removeElementById = function(id) { var element = document.getElementById(id); if (element && element.parentNode) { element.parentNode.removeChild(element); }};
window.AG_removeElementBySelector = function(selector) { if (!document.querySelectorAll) { return; } var nodes = document.querySelectorAll(selector); if (nodes) { for (var i = 0; i < nodes.length; i++) { if (nodes[i] && nodes[i].parentNode) { nodes[i].parentNode.removeChild(nodes[i]); } } } };
window.AG_each = function(selector, fn) { if (!document.querySelectorAll) return; var elements = document.querySelectorAll(selector); for (var i = 0; i < elements.length; i++) { fn(elements[i]); }; };
var AG_removeParent = function(el, fn) { while (el && el.parentNode) { if (fn(el)) { el.parentNode.removeChild(el); return; } el = el.parentNode; } };
var AG_onLoad=function(func){if(document.readyState==="complete"||document.readyState==="interactive")func();else if(document.addEventListener)document.addEventListener("DOMContentLoaded",func);else if(document.attachEvent)document.attachEvent("DOMContentLoaded",func)};
var AG_removeElementById = function(id) { var element = document.getElementById(id); if (element && element.parentNode) { element.parentNode.removeChild(element); }};
var AG_removeElementBySelector = function(selector) { if (!document.querySelectorAll) { return; } var nodes = document.querySelectorAll(selector); if (nodes) { for (var i = 0; i < nodes.length; i++) { if (nodes[i] && nodes[i].parentNode) { nodes[i].parentNode.removeChild(nodes[i]); } } } };
var AG_each = function(selector, fn) { if (!document.querySelectorAll) return; var elements = document.querySelectorAll(selector); for (var i = 0; i < elements.length; i++) { fn(elements[i]); }; };
var AdFox_getCodeScript = function() {};
AG_onLoad(function() { AG_each('iframe[id^="AdFox_iframe_"]', function(el) { if (el && el.parentNode) { el.parentNode.removeChild(el); } }); });
try { Object.defineProperty(window, 'noAdsAtAll', { get: function() { return true; } }); } catch (ex) {}
window.uabInject = function() {};
} catch (ex) { console.error('Error executing AG js: ' + ex); }</script></head>
<body>

<div class="g">
<table class="g1" width="100%" border="1">
<tbody><tr><td class="g1">
<a class="g2" href="http://ivr.webzone.ru/index.htm">Страница&nbsp;Ивана&nbsp;Рощина</a>&nbsp;&gt;
<a class="g2" href="http://ivr.webzone.ru/articles/index.htm">Статьи</a>&nbsp;&gt;
</td></tr>
</tbody></table>
</div>

<p class="f">© Иван Рощин, Москва</p>

<div align="left">
<table cellspacing="0" cellpadding="0">
<tbody><tr><td nowrap="">E-mail</td><td nowrap="">: <a href="mailto:bestview@mtu-net.ru">bestview@mtu-net.ru</a></td></tr>
<tr><td>WWW</td><td nowrap="">: <a href="http://www.ivr.da.ru/">http://www.ivr.da.ru</a></td></tr>
</tbody></table>
</div>

<h1>Без&nbsp;ошибок и&nbsp;опечаток</h1>

<p class="f">(«<a href="http://www.osp.ru/pcworld/">Мир ПК</a>»
11/2007)</p>

<div>
<a href="http://ivr.webzone.ru/articles/autocorr/index.htm#n1">Основная идея</a><br>
<a href="http://ivr.webzone.ru/articles/autocorr/index.htm#n2">Первые шаги</a><br>
<a href="http://ivr.webzone.ru/articles/autocorr/index.htm#n3">Автоматизация пополнения словаря</a><br>
<a href="http://ivr.webzone.ru/articles/autocorr/index.htm#n4">Первоначальный алгоритм создания или&nbsp;дополнения словаря</a><br>
<a href="http://ivr.webzone.ru/articles/autocorr/index.htm#n5">Выявленный недостаток. Доработка алгоритма</a><br>
<a href="http://ivr.webzone.ru/articles/autocorr/index.htm#n6">Доработанный алгоритм создания или&nbsp;дополнения словаря</a><br>
<a href="http://ivr.webzone.ru/articles/autocorr/index.htm#n7">Дальнейшие усовершенствования</a><br>
<a href="http://ivr.webzone.ru/articles/autocorr/index.htm#n8">Окончательный алгоритм создания или&nbsp;дополнения словаря</a><br>
<a href="http://ivr.webzone.ru/articles/autocorr/index.htm#n9">Окончательная программа. Руководство пользователя</a><br>
<a href="http://ivr.webzone.ru/articles/autocorr/index.htm#n10">Регулярные выражения</a>
<div style="margin-left: 2em">
<a href="http://ivr.webzone.ru/articles/autocorr/index.htm#n10_1">1. Класс символов</a><br>
<a href="http://ivr.webzone.ru/articles/autocorr/index.htm#n10_2">2. Альтернатива</a><br>
<a href="http://ivr.webzone.ru/articles/autocorr/index.htm#n10_3">3. Указание количества повторов</a><br>
<a href="http://ivr.webzone.ru/articles/autocorr/index.htm#n10_4">4. Условия</a><br>
<a href="http://ivr.webzone.ru/articles/autocorr/index.htm#n10_5">5. Подстановка</a>
</div>
<a href="http://ivr.webzone.ru/articles/autocorr/index.htm#n11">Исправление ошибочного слитного и&nbsp;раздельного написания</a><br>
<a href="http://ivr.webzone.ru/articles/autocorr/index.htm#n12">«Почти хорошие» ошибки</a><br>
<a href="http://ivr.webzone.ru/articles/autocorr/index.htm#n13">Разное</a><br>
<a href="http://ivr.webzone.ru/articles/autocorr/index.htm#n14">Приложение</a>
</div>

<h2><a name="n1">Основная идея</a></h2>

<p>При редактировании текстовых файлов мне часто приходится исправлять
орфографические ошибки и опечатки (далее для краткости все они называются
ошибками). Естественным было попытаться облегчить себе эту работу с помощью
компьютера.</p>

<p>За счёт чего это можно сделать? Некоторые ошибки (назовём их
«хорошими») допустимо исправлять автоматической заменой
ошибочного слова на правильное, например: <nobr>«собераюсь»
-&gt;</nobr> «собираюсь». Однако далеко не все ошибки таковы.
Предположим, неправильно написано «садится» вместо
«садиться»&nbsp;— оба эти слова есть в русском языке, поэтому
автоматически заменять одно на другое нельзя. Или, скажем,
«оптека»&nbsp;— непонятно, что же должно быть на самом деле,
то ли «оптика», то ли «аптека».</p>

<p>Так вот, если написать программу, исправляющую хотя бы наиболее
распространённые «хорошие» ошибки, то объём ручной работы заметно
сократится. Ведь чтобы исправить одну ошибку вручную, нужно выполнить целую
последовательность действий, например: подвести курсор к нужному месту текста,
удалить неправильный или лишний символ и/или вставить правильный. Бывают
ошибки и в двух символах, переставленных местами, и ещё более сложные.
Особенно полезной такая программа будет при обработке текстов с большим
количеством ошибок.</p>

<p>Разумеется, если в тексте с <nobr>какой-то</nobr> целью присутствуют слова,
специально написанные неправильно (как, например, в этой статье), то нужно
либо отказаться от автоисправления ошибок, либо получившийся после него текст
сравнить с исходным, проверяя, не произошло ли ненужных исправлений.</p>

<h2><a name="n2">Первые шаги</a></h2>

<p>Для начала я написал простейшую программу на Perl (этот язык весьма удобен
для работы с текстами), которая читала исходный текстовый файл, исправляла
часть ошибок с помощью замен неправильных слов на правильные и записывала
результат. Для простоты я решил ограничиться обработкой таких текстовых
файлов, где не используются переносы слов.</p>

<p>Участок программы, исправляющий ошибки, представлял собой
последовательность операторов <nobr>поиска-замены</nobr> следующего вида:</p>

<pre>s/(?&lt;![[:alpha:]'-])неправильное слово(?![[:alpha:]'-])/правильное слово/g;
</pre>

<p>Здесь конструкция <nobr>«(?&lt;![[:alpha:]'-])»</nobr>
означает, что в тексте не должно быть буквы, символа «'» или
<nobr>«-»</nobr> перед заменяемым словом, а конструкция
<nobr>«(?![[:alpha:]'-])» —</nobr> что таких символов не
должно быть после него. Эти условия необходимы, чтобы избежать замены в том
случае, когда найденная в тексте последовательность символов, совпадающая с
неправильным словом, в действительности является частью <nobr>какого-то</nobr>
другого слова.</p>

<p class="up">Чтобы программа была эффективной, она должна исправлять как
можно больше ошибок. А значит, нужно было добавлять в неё операторы для
исправления новых ошибок. Я это делал прямо в процессе редактирования текста.
Дабы меньше отвлекаться от этой своей основной задачи, я, исправив очередную
«хорошую» ошибку, добавлял оператор для её исправления, только
если она встречалась достаточно часто.</p>

<p class="up">Следующим шагом было некоторое упрощение добавления информации
для исправления ошибок. Я изменил программу так, чтобы пары из неправильного и
правильного слов содержались не непосредственно в операторах
<nobr>поиска-замены,</nobr> а в отдельном <nobr>файле-словаре</nobr> в виде
«неправильное <nobr>слово -&gt;</nobr> правильное слово».
Программа читала содержимое этого словаря и в соответствии с ним выполняла
замены. Добавить новую пару в словарь было несколько проще, чем добавить новый
оператор <nobr>поиска-замены</nobr> в программу.</p>

<p class="up">Хотелось бы, однако, пополнять словарь так, чтобы вовсе не
приходилось отвлекаться от редактирования текста. Например, сначала
отредактировать текст, а потом, в удобное время, сравнить исходный текст с
отредактированным, находя исправленные слова и добавляя в словарь
«хорошие» пары слов (т.е. соответствующие «хорошим»
ошибкам). Но это процесс трудоёмкий, и выполняя его вручную, легко
<nobr>что-нибудь</nobr> пропустить.</p>

<h2><a name="n3">Автоматизация пополнения словаря</a></h2>

<p>К счастью, возникла идея почти полной автоматизации этого процесса. Пусть
специальная программа сравнивает исходный текст с отредактированным, находя
исправленные слова. Найденные пары слов (слово с ошибкой и исправленный
вариант) она будет предъявлять пользователю, который и вынесет вердикт:
является ли данная пара «хорошей» или нет. «Хорошие»
пары программа добавит к словарю.</p>

<p>То есть тут человек берёт на себя именно ту часть работы, которую
компьютеру выполнить затруднительно: оценивает, является ли очередная пара
слов «хорошей». А всё остальное делается автоматически.</p>

<p class="up">Руководствуясь вышеизложенным, предстояло разработать алгоритм и
написать требуемую программу для пополнения словаря.</p>

<p class="up">Ясно, что прежде всего такая программа должна уметь выделять в
тексте отдельные слова. А для этого она должна знать, что такое слово.
<nobr>Мы-то</nobr> знаем, что это такое, а вот как объяснить это компьютеру? Я
принял, что словом будет считаться последовательность символов (в том числе и
состоящая всего из одного знака), обладающая следующими свойствами:</p>
<ul class="mini-ul">
<li>в неё могут входить символы из множества, включающего буквы, дефис,
апостроф;
</li><li>ни один из символов, принадлежащих к этому множеству, не находится
непосредственно слева или справа от последовательности;
</li><li>первый и последний символы последовательности&nbsp;— буквы.
</li></ul>

<p class="up">Тогда слово может быть описано следующим регулярным выражением
Perl (оно разбито на строки для удобства чтения и комментирования):</p>

<pre>(?&lt;![[:alpha:]'-]) # Условие: слева нет ни буквы, ни "'", ни "-".
(?=[[:alpha:]])    # Условие: справа есть буква.
[[:alpha:]'-]+     # Последовательность букв, "'", "-".
(?&lt;=[[:alpha:]])   # Условие: слева есть буква.
(?![[:alpha:]'-])  # Условие: справа нет ни буквы, ни "'", ни "-".
</pre>

<p>Далее надо было решить, каким образом программа, сравнивая исходный текст с
отредактированным, будет находить пары слов (слово с ошибкой и исправленное
слово).</p>

<p>Если бы при редактировании порядок слов оставался одним и тем же, никакие
слова не добавлялись бы и не удалялись, одни слова не заменялись на другие, а
исключительно лишь исправлялись ошибки, то всё было бы просто: берём первое
слово исходного текста и сравниваем его с первым словом отредактированного;
если не совпадают&nbsp;— значит, эти слова и образуют искомую пару; затем
точно так же сравниваем вторые слова текстов, третьи и т.д.</p>

<p>Но в действительности при редактировании текст может подвергаться весьма
существенным изменениям, поэтому подобный способ непригоден. Тогда можно пойти
другим путём: искать такие пары слов (первое слово из исходного текста, а
второе из отредактированного), в которых второе слово может быть исправлением
первого.</p>

<p>То есть надо уметь определять для пары слов: может ли второе слово быть
исправлением первого? Для этого надо знать, какого рода ошибки обычно
допускаются в словах. По своему опыту могу сказать, что чаще всего встречаются
такие ошибки: вместо одной буквы стоит другая; добавлена лишняя буква;
пропущена буква; переставлены две соседние буквы.</p>

<p>Исходя из этого, я решил считать, что второе слово может быть исправлением
первого, если слова различны и выполняется одно из условий:</p>
<ul class="mini-ul">
<li>второе слово&nbsp;— это первое без одного символа;
</li><li>второе слово&nbsp;— это первое с одним добавленным символом;
</li><li>второе слово&nbsp;— это первое с одним изменённым символом;
</li><li>второе слово&nbsp;— это первое с переставленными двумя соседними
символами.
</li></ul>

<p class="up">Конечно, если в <nobr>каком-то</nobr> слове была более сложная
ошибка, то программа не сможет найти его исправленную версию и предъявить эту
пару слов пользователю. Но такие случаи редки, к тому же соответствующую пару
можно добавить в словарь вручную. В то же время если расширить список
критериев, по которым второе слово может быть исправлением первого (т.е.
учитывать более сложные ошибки в словах), то повышается риск того, что это
окажутся совсем разные слова (так, если считать, что ошибки могут быть в
четырёх символах, то получается, что слово «муха» может быть
исправлением ошибки в слове «слон»)&nbsp;— в результате
пользователь потеряет массу времени на исключение посторонних пар слов.</p>

<p class="up">При редактировании текста одно предложение нередко разбивается
на два, и поэтому в слове, оказавшемся в начале второго предложения, строчная
буква становится прописной. Или два предложения объединяются в одно, и тогда в
слове, которое было в начале второго предложения, прописная буква становится
строчной. Иногда автор начинает предложение со строчной буквы, и приходится
исправлять её на прописную. Пары, соответствующие таким исправлениям
(например, <nobr>«быстро -&gt;</nobr> Быстро»), нельзя отнести к
«хорошим», так как оба слова в них являются допустимыми. Так вот,
чтобы пользователь не тратил времени на просмотр подобных пар и отказ от их
добавления в словарь, я решил ввести условие: пары слов, различающихся лишь
регистром, считаются неподходящими и не предъявляются пользователю.
<nobr>Из-за</nobr> этого, правда, не будут предъявлены и «хорошие»
пары типа <nobr>«москва -&gt;</nobr> Москва», но их можно добавить
в словарь вручную.</p>

<p class="up">При поиске пар я решил рассматривать лишь слова длиной не меньше
минимальной (я принял её равной четырём символам). Иначе возможно предъявление
слишком большого количества неподходящих пар (например, <nobr>«но
-&gt;</nobr> не», <nobr>«но -&gt;</nobr> он»,
<nobr>«но -&gt;</nobr> то»). Ведь для коротких незначительно
отличающихся слов велика вероятность того, что они окажутся не парой из
неправильного и исправленного слова, а просто разными словами.
<nobr>Опять-таки</nobr> добавить в словарь <nobr>какие-либо</nobr> пары
коротких слов можно вручную.</p>

<p class="up">Упрощает поиск пар такая оптимизация: не рассматривать случаи,
где первое слово является допустимым (ведь допустимые слова нельзя заменять
автоматически на <nobr>что-то,</nobr> значит, эти пары всё равно будут
отвергнуты). Для проверки допустимости слова можно использовать то
обстоятельство, что правильными являются все слова отредактированного текста
(ведь ошибки в нём уже исправлены) и вторые слова в парах словаря (по
определению). То есть если проверяемое слово среди них присутствует, значит,
оно допустимо. Конечно, этот способ проверки неточен&nbsp;— проверяемое
слово может быть допустимым и в то же время отсутствовать среди известных
программе допустимых слов, но это приведёт лишь к невозможности оптимизации
для данного конкретного слова.</p>

<p>Также не имеет смысла рассматривать пары, где о первом слове уже известно,
что оно неправильное и как его надо исправить (т.е. в словаре уже есть пара с
таким первым словом).</p>

<p>И конечно, в процессе работы программы нет смысла предъявлять пользователю
<nobr>какую-либо</nobr> пару повторно.</p>

<h2><a name="n4">Первоначальный алгоритм создания или&nbsp;дополнения
словаря</a></h2>

<div class="list">
<ol>
<li>Построим множество source, содержащее (без повторов) все слова достаточной
длины из исходного текста. Под достаточной длиной здесь и далее понимается
длина не меньше минимальной&nbsp;— о ней я говорил в предыдущем разделе.

</li><li>Построим множество edited, содержащее (без повторов) все слова достаточной
длины из отредактированного текста.

</li><li>Построим множество good_words из слов, содержащихся в множестве edited.
Это множество будет обладать тем свойством, что слова в нём не повторяются и
являются допустимыми.

</li><li>Если словаря нет, переходим к п.&nbsp;7.

</li><li>Заполним (без повторов) множество bad_words (изначально пустое) такими
первыми словами пар из словаря, которые имеют достаточную длину. Полученное
множество будет обладать тем свойством, что слова в нём не повторяются,
являются неправильными и для них в словаре уже содержится информация о том,
как они должны быть исправлены.

</li><li>Дополним (без повторов) множество good_words такими вторыми словами пар из
словаря (они являются правильными словами), которые имеют достаточную длину.
После этого good_words <nobr>по-прежнему</nobr> будет обладать свойствами,
упомянутыми в п.&nbsp;3.

</li><li>Главный цикл. Для каждого слова из source выполняем:

<div class="letters">
<div class="letter">
а)&nbsp;если оно содержится в good_words, значит, это допустимое слово, на
этом его обработка завершается;
</div>

<div class="letter">
б)&nbsp;если оно есть в bad_words, значит, в словаре уже есть пара для
исправления этого слова, на этом его обработка завершается;
</div>

<div class="letter">
в)&nbsp;построим множество m, содержащее такие слова из edited, которые могут
быть исправлениями текущего слова (критерий, по которому определяется, может
ли одно слово быть исправлением другого, был описан ранее) и при этом
отличаются от текущего слова не только регистром. Если таких слов не нашлось,
то на этом обработка текущего слова завершается;
</div>

<div class="letter">
г)&nbsp;по очереди предъявляем пользователю пары, где первое слово&nbsp;—
текущее, а второе&nbsp;— очередное слово из множества m, до тех пор, пока
либо пользователь не подтвердит <nobr>какую-либо</nobr> пару, либо не
отвергнет все пары. В первом случае добавляем подтверждённую пару в словарь.
</div>
</div>

</li></ol>
</div>

<p class="up">Замечу, что так как множества source и edited не содержат
повторяющихся элементов и каждое слово из source не более одного раза
сопоставляется со словами из edited, то не нужно специально следить за тем,
чтобы никакая пара слов не предъявлялась пользователю повторно,&nbsp;—
это получится само собой.</p>

<p class="up">Рассмотрим работу алгоритма на простом примере.</p>

<p class="up">Исходный текст:<br>
Но, вопервых, отметим дезайн аппарата.</p>

<p class="up">Отредактированный текст:<br>
Но, <nobr>во-первых,</nobr> отметим великолепный дизайн аппарата.</p>

<p class="up">Исходный словарь:<br>
<nobr>ешё -&gt;</nobr> ещё<br>
<nobr>дезайн -&gt;</nobr> дизайн</p>

<p class="up">В каждом из нижеприведённых пунктов показывается, что получится
в результате выполнения соответствующего пункта алгоритма.</p>

<div class="list">
<ol>
<li>Множество source будет содержать слова «вопервых»,
«отметим», «дезайн», «аппарата». Слово
«Но», так как его длина не является достаточной, не будет
добавлено к множеству.

</li><li>Множество edited будет содержать слова
<nobr>«во-первых»,</nobr> «отметим»,
«великолепный», «дизайн», «аппарата».
Точно так же слово «Но» не будет добавлено к множеству.

</li><li>Множество good_words будет содержать слова
<nobr>«во-первых»,</nobr> «отметим»,
«великолепный», «дизайн», «аппарата».

</li><li>Так как словарь есть, к п.&nbsp;7 не переходим.

</li><li>Множество bad_words будет содержать слово «дезайн». Слово
«ешё», так как его длина не является достаточной, не будет
добавлено к множеству.

</li><li>Дополненное множество good_words будет содержать слова
<nobr>«во-первых»,</nobr> «отметим»,
«великолепный», «дизайн», «аппарата», т.е.
не изменится: слово «ещё» не будет добавлено к нему, так как его
длина не является достаточной, а слово «дизайн»&nbsp;— потому
что оно уже содержится в множестве.

</li><li>Главный цикл. Рассмотрим обработку каждого слова из source:

<ul>
<li>«вопервых»&nbsp;— слова нет в good_words и в bad_words.
Построенное множество m будет состоять из единственного слова
<nobr>«во-первых».</nobr> Предъявляем пользователю пару
<nobr>«вопервых -&gt;</nobr> <nobr>во-первых».</nobr> Допустим, он
подтвердил её. Добавляем эту пару в словарь;

</li><li>«отметим»&nbsp;— слово есть в good_words, на этом его
обработка завершается;

</li><li>«дезайн»&nbsp;— слова нет в good_words, но оно есть в
bad_words, на этом его обработка завершается;

</li><li>«аппарата»&nbsp;— слово есть в good_words, на этом его
обработка завершается.
</li></ul>

</li></ol>
</div>

<p class="up">В итоге словарь станет таким:<br>
<nobr>ешё -&gt;</nobr> ещё<br>
<nobr>дезайн -&gt;</nobr> дизайн<br>
<nobr>вопервых -&gt;</nobr> <nobr>во-первых</nobr></p>

<h2><a name="n5">Выявленный недостаток. Доработка алгоритма</a></h2>

<p>В соответствии с алгоритмом я написал первоначальную версию программы для
создания или дополнения словаря и объединил её с ранее упоминавшейся
программой для исправления текста по словарю. Теперь одна программа будет
выполнять все операции, а нужный режим работы можно указать в командной
строке.</p>

<p>Программа была опробована в режиме создания или дополнения словаря. И что
бы вы думали? Хоть я при её разработке и уделял внимание тому, чтобы по
возможности пользователю не предъявлялись неподходящие пары слов, проблема
оказалась именно в этом.</p>

<p>Например, в исходном тексте есть слово «делал», а из
отредактированного текста оно вообще было убрано, но там есть слова, которые
по принятому критерию могут быть его исправлениями: «дела»,
«делала», «делали». Тогда программа предъявит
пользователю пары <nobr>«делал -&gt;</nobr> дела»,
<nobr>«делал -&gt;</nobr> делала», <nobr>«делал -&gt;</nobr>
делали», и пользователь потратит время, отвергая их. (Я подразумеваю,
что слова «делал» нет также и среди вторых слов пар словаря, так
что программа не может сделать вывод, что оно является допустимым и поэтому не
надо рассматривать пары с этим первым словом.)</p>

<p>Проблема в том, что программа предъявляет те пары, где второе слово хоть и
может быть по принятому критерию исправлением первого, но в действительности
при редактировании текста подобного исправления не производилось, первое слово
в исходном тексте никак не связано со вторым словом в отредактированном
тексте, а просто эти слова оказались похожими.</p>

<p>Чтобы избежать предъявления подобных неподходящих пар, я решил ввести
дополнительное условие: рассматривать только такие пары, где слова находятся в
одинаковом контексте (т.е. первое слово пары должно быть в исходном тексте в
окружении тех же слов, что и второе слово пары в отредактированном тексте).
Ведь слова, лишь случайно похожие друг на друга, почти наверняка окажутся в
разном контексте.</p>

<p>Длина контекста (то есть количество рассматриваемых соседних слов) не
должна быть как слишком малой (чтобы избежать случайного совпадения
контекста), так и слишком большой (чем больше контекст, тем больше вероятность
того, что он изменится при редактировании). Я выбрал длину контекста в одно
слово до рассматриваемого и одно слово после. То есть слева и справа от
первого слова пары в исходном тексте должны быть те же самые слова, что слева
и справа от второго слова пары в отредактированном тексте.</p>

<h2><a name="n6">Доработанный алгоритм создания или&nbsp;дополнения
словаря</a></h2>

<div class="list">
<ol>
<li>Создадим массив source: первый элемент&nbsp;— пустое слово, следующие
элементы&nbsp;— слова из исходного текста (в таком же порядке, как в
тексте), и последний элемент&nbsp;— опять пустое слово. Эти пустые слова
нужны, чтобы в дальнейшем для каждого слова исходного текста был определён
контекст.

</li><li>Точно так же по отредактированному тексту создадим массив edited.

</li><li>Создадим структуру данных, состоящую из хеша by_context и дополнительных
массивов, нужную для того, чтобы в дальнейшем можно было быстро узнавать,
какие слова достаточной длины встречаются в edited непосредственно между двумя
заданными словами. В каждом элементе этого хеша ключ&nbsp;— два слова из
edited, перечисленные через запятую, а значение&nbsp;— ссылка на
созданный массив слов, длина которых достаточна и которые встречаются в edited
непосредственно между этими двумя словами; этот массив не должен содержать
повторов. Если для <nobr>каких-то</nobr> двух слов соответствующий массив
оказывается пуст, то и элемент хеша не создаётся.

<div class="up">
Создание вышеописанной структуры данных происходит так.
</div>

<div class="up">
Изначально хеш by_context пуст. Создадим вспомогательное множество temp.
Введём определение: тройка слов&nbsp;— это три слова, идущие подряд. Так
вот, элементами множества temp будут все различные тройки слов (слова в них
разделяются запятыми) из edited, причём второе слово в тройке&nbsp;—
достаточной длины. Затем для каждого элемента temp выполняем следующее:
</div>

<div class="letters">
<div class="letter">
а)&nbsp;разбиваем его на составляющие&nbsp;— получаем три слова,
обозначим их 1, 2, 3;
</div>

<div class="letter">
б)&nbsp;если в by_context есть элемент с ключом из слов 1 и 3, то добавляем к
массиву, соответствующему этому элементу, слово 2. Такого слова заведомо нет в
массиве&nbsp;— оно могло бы там быть, только если ранее уже была
обработана точно такая же тройка слов, а это исключено, потому что все
обрабатываемые тройки слов различны;
</div>

<div class="letter">
в)&nbsp;иначе (в by_context нет элемента с ключом из слов 1 и 3) создаём этот
элемент, а его значением будет ссылка на массив (который также нужно создать),
состоящий из одного элемента&nbsp;— слова 2.
</div>
</div>

</li><li>Построим множество good_words из слов достаточной длины, содержащихся в
массиве edited, кроме повторов. Это множество будет обладать тем свойством,
что слова в нём не повторяются и являются допустимыми.

</li><li>Если словаря нет, переходим к п.&nbsp;8.

</li><li>Заполним множество bad_words (изначально пустое) первыми словами пар из
словаря, обладающими достаточной длиной, без повторов. Полученное множество
будет обладать такими свойствами: слова в нём не повторяются, являются
неправильными и для них в словаре уже содержится информация о том, как они
должны быть исправлены.

</li><li>Дополним множество good_words вторыми словами пар из словаря (они являются
правильными словами), обладающими достаточной длиной. Добавление производится
так, чтобы в good_words не возникло повторов. После этого good_words
<nobr>по-прежнему</nobr> будет обладать свойствами, упомянутыми в п.&nbsp;4.

</li><li>Главный цикл. Для каждого слова из source, кроме пустых слов в начале и
конце, выполняем:

<div class="letters">
<div class="letter">
а)&nbsp;если длина слова меньше минимальной, на этом его обработка
завершается;
</div>

<div class="letter">
б)&nbsp;если оно есть в good_words, значит, это допустимое слово, на этом его
обработка завершается;
</div>

<div class="letter">
в)&nbsp;если оно есть в bad_words, значит, в словаре уже есть пара для
исправления этого слова, на этом его обработка завершается;
</div>

<div class="letter">
г)&nbsp;берём контекст текущего слова&nbsp;— слова слева и справа от
него&nbsp;— и составляем из них ключ (строку из этих двух слов,
разделённых запятой). Если в хеше by_context нет элемента с таким ключом,
значит, в отредактированном тексте нет ни одного слова достаточной длины с
таким контекстом, и на этом обработка текущего слова завершается;
</div>

<div class="letter">
д)&nbsp;внутренний цикл. Для каждого слова из массива, соответствующего
вышеуказанному ключу в хеше by_context (обозначим это слово j, а текущее слово
главного цикла&nbsp;— w), выполняем:

<ul>
<li>если j отличается от w только регистром, то на этом обработка j
завершается;

</li><li>если j не может быть исправлением w, то на этом обработка j завершается;

</li><li>если пара <nobr>w -&gt;</nobr> j есть в множестве bad_pairs (там хранятся
отвергнутые пользователем пары, изначально оно пусто), то на этом обработка j
завершается;

</li><li>предъявляем пользователю пару <nobr>w -&gt;</nobr> j. Если он подтвердил
её, то добавляем её в словарь, добавляем w в bad_words, и внутренний цикл
прерывается. А если пользователь отверг пару, то добавляем её в множество
bad_pairs, и на этом обработка j завершается.
</li></ul>
</div>
</div>

</li></ol>
</div>

<p class="up">Рассмотрим работу алгоритма на примере.</p>

<p class="up">Исходный текст:<br>
Также, когда я взял телефон, то обратил внимание на его дисплэй.</p>

<p class="up">Отредактированный текст:<br>
Также, взяв телефон, я обратил внимание на его дисплей.</p>

<p class="up">Словарь отсутствует.</p>

<p class="up">В каждом из нижеприведённых пунктов показывается, что получится
в результате выполнения соответствующего пункта алгоритма.</p>

<div class="list">
<ol>
<li>Массив source будет следующим: «», «Также»,
«когда», «я», «взял»,
«телефон», «то», «обратил»,
«внимание», «на», «его»,
«дисплэй», «».

</li><li>Массив edited будет следующим: «», «Также»,
«взяв», «телефон», «я»,
«обратил», «внимание», «на»,
«его», «дисплей», «».

</li><li>Множество temp будет содержать элементы «,Также,взяв»,
«Также,взяв,телефон», «взяв,телефон,я»,
«я,обратил,внимание», «обратил,внимание,на»,
«его,дисплей,». Элементы «телефон,я,обратил»,
«внимание,на,его», «на,его,дисплей» не будут добавлены
к множеству, так как у них длина второго слова не является достаточной.

<div class="up">
Хеш by_context и дополнительные массивы будут следующими:
</div>

<div align="center">
<table border="1" cellpadding="5" class="c">
<caption align="bottom">Таблица&nbsp;1</caption>
<tbody><tr align="center">
<th>Ключ</th>
<th>Значение</th>
</tr>
<tr align="center">
<td>«,взяв»</td>
<td>Ссылка на&nbsp;массив из&nbsp;одного элемента «Также»</td>
</tr>
<tr align="center">
<td>«Также,телефон»</td>
<td>—/—&nbsp;«взяв»</td>
</tr>
<tr align="center">
<td>«взяв,я»</td>
<td>—/—&nbsp;«телефон»</td>
</tr>
<tr align="center">
<td>«я,внимание»</td>
<td>—/—&nbsp;«обратил»</td>
</tr>
<tr align="center">
<td>«обратил,на»</td>
<td>—/—&nbsp;«внимание»</td>
</tr>
<tr align="center">
<td>«его,»</td>
<td>—/—&nbsp;«дисплей»</td>
</tr>
</tbody></table>
</div>

</li><li>Множество good_words будет содержать слова «Также»,
«взяв», «телефон», «обратил»,
«внимание», «дисплей».

</li><li>Так как словаря нет, переходим к п.&nbsp;8.

</li><li value="8">Рассмотрим обработку каждого слова из source, кроме пустых слов
в начале и конце:

<ul>
<li>«Также»: длина слова не меньше минимальной; оно есть в
good_words&nbsp;— на этом его обработка завершается;

</li><li>«когда»: длина слова не меньше минимальной; его нет в
good_words; его нет в bad_words; ключ, составленный из слов слева и справа от
него, будет «Также,я», в хеше by_context нет элемента с таким
ключом&nbsp;— на этом обработка слова завершается;

</li><li>«я»: длина слова меньше минимальной&nbsp;— на этом его
обработка завершается;

</li><li>«взял»: длина слова не меньше минимальной; его нет в
good_words; его нет в bad_words; ключ, составленный из слов слева и справа от
него, будет «я,телефон», в хеше by_context нет элемента с таким
ключом&nbsp;— на этом обработка слова завершается;

</li><li>«телефон»: длина слова не меньше минимальной; оно есть в
good_words&nbsp;— на этом его обработка завершается;

</li><li>«то»: длина слова меньше минимальной&nbsp;— на этом его
обработка завершается;

</li><li>«обратил»: длина слова не меньше минимальной; оно есть в
good_words&nbsp;— на этом его обработка завершается;

</li><li>«внимание»: длина слова не меньше минимальной; оно есть в
good_words&nbsp;— на этом его обработка завершается;

</li><li>«на»: длина слова меньше минимальной&nbsp;— на этом его
обработка завершается;

</li><li>«его»: длина слова меньше минимальной&nbsp;— на этом его
обработка завершается;

</li><li>«дисплэй»: длина слова не меньше минимальной; его нет в
good_words; его нет в bad_words; ключ, составленный из слов слева и справа от
него, будет «его,»; в хеше by_context есть элемент с таким ключом,
ему соответствует массив из одного слова «дисплей»; оно отличается
от «дисплэй» не только регистром; оно может быть исправлением
слова «дисплэй»; пары <nobr>«дисплэй -&gt;</nobr>
дисплей» нет в множестве bad_pairs; предъявляем её пользователю;
допустим, он подтвердил её; добавляем её в словарь, добавляем
«дисплэй» в bad_words, и на этом обработка слова
«дисплэй» завершается.
</li></ul>

</li></ol>
</div>

<p class="up">В итоге словарь будет содержать: <nobr>дисплэй -&gt;</nobr>
дисплей.</p>

<p class="up">Отмечу, что если бы для обработки исходных данных этого примера
применялся первоначальный алгоритм, то пользователю была бы предъявлена ещё и
пара <nobr>«взял -&gt;</nobr> взяв», от которой он отказался бы,
но всё равно потратил бы время на её рассмотрение. В данном же примере эта
пара не предъявляется, ведь у слов «взял» в исходном тексте и
«взяв» в отредактированном тексте&nbsp;— разный контекст: у
первого&nbsp;— слова «я» и «телефон», а у
второго&nbsp;— «Также» и «телефон».</p>

<h2><a name="n7">Дальнейшие усовершенствования</a></h2>

<p>Когда часть программы, отвечающая за создание или дополнение словаря, была
переписана в соответствии с вышеизложенным алгоритмом, мои ожидания
оправдались: программа предъявляла пользователю меньше неподходящих пар. Затем
я решил расширить её возможности.</p>

<p class="up">Допустим, при дополнении словаря была добавлена пара
<nobr>«тедефона -&gt;</nobr> телефона». Такая ошибка может
встретиться и в других подобных словах: например, может быть написано
«тедефоном» вместо «телефоном» и т.д. Неплохо было бы
исправлять и такие ошибки. Чтобы не добавлять в словарь все возможные пары,
где различаются только окончания, я решил сделать так: пусть символ
«~» в конце слова означает любое окончание (в т.ч. пустое), при
этом в качестве слова для замены указывается то, на что будет заменено начало
слова (окончание исправленного слова остаётся каким было). Таким образом, для
рассматриваемого примера вместо исходной пары можно было бы записать такую:
<nobr>«тедефон~ -&gt;</nobr> телефон».</p>

<p>Также пусть «~» в начале слова означает любое начало (в том
числе пустое). Допустим, нужно исправлять ошибки в словах
<nobr>«кто-нибуть»,</nobr> <nobr>«когда-нибуть»</nobr>
и т.п., где требуется исправить окончание <nobr>«-нибуть»</nobr>
на <nobr>«-нибудь».</nobr> Тогда, чтобы не создавать отдельную
пару для каждого такого слова, можно записать универсальную пару
<nobr>«~-нибуть -&gt;</nobr> <nobr>-нибудь».</nobr></p>

<p>Соответственно, поставив «~» и в начале и в конце, мы получим
возможность заменять середину слова, оставляя без изменений его начало и
окончание. Это тоже может быть полезным. Например, нужно исправлять слова с
корнем «объект», если он неправильно записан как
«обьект» (примеры ошибочных слов: «обьекта»,
«необьективному»). Для этого можно добавить в словарь пару
<nobr>«~обьект~ -&gt;</nobr> объект».</p>

<p>Естественно, при использовании «~» надо следить, чтобы под
получившуюся универсальную замену не попали <nobr>какие-либо</nobr> другие
слова, не те, что задумывалось. Иначе при исправлении текста они окажутся
искажены.</p>

<p class="up">Ещё одна идея по улучшению программы была такой. Поскольку
исправление производится с помощью оператора <nobr>поиска-замены</nobr> (о
чём уже говорилось в начале статьи), а в этом операторе предусмотрено
использование регулярных выражений, то естественным было бы использовать
регулярные выражения и в парах словаря (далее этому посвящён отдельный раздел
статьи&nbsp;— «<a href="http://ivr.webzone.ru/articles/autocorr/index.htm#n10">Регулярные выражения</a>»).</p>

<p class="up">Так как теперь в парах словаря могут быть не только слова, но и
выражения, то далее я буду вместо «первое слово пары»,
«второе слово пары» писать «первый член пары»,
«второй член пары».</p>

<p class="up">Следующая идея. При использовании программы было такое
неудобство. Допустим, при пополнении словаря добавилась пара
<nobr>«выгледит -&gt;</nobr> выглядит». Но исправление будет
происходить лишь в точности для такого слова, а если оно расположено в начале
предложения и, соответственно, начинается с прописной буквы, то исправления не
будет. Чтобы оно осуществлялось, придётся вручную добавить в словарь пару
<nobr>«Выгледит -&gt;</nobr> Выглядит». И наоборот, если в словаре
есть пара <nobr>«Выгледит -&gt;</nobr> Выглядит», то не будет
производиться исправление <nobr>«выгледит -&gt;</nobr>
выглядит», пока не добавишь такую пару.</p>

<p>И я решил: если оба члена находящейся в словаре пары начинаются с прописной
буквы или оба со строчной, то при исправлении текста пусть всё происходит так,
как если бы в словаре вместо этой пары было две: у одной оба члена начинаются
со строчной буквы, а у другой&nbsp;— с прописной, чтобы не приходилось
вручную добавлять пары с другим регистром первой буквы.</p>

<p>Если же для <nobr>какой-то</nobr> пары нужно отключить такую возможность,
то для этого достаточно заключить первый член пары в скобки. Тогда он будет
начинаться со скобки, а не с буквы, что и приведёт к отключению.</p>

<p class="up">В связи с добавлением вышеописанных новых возможностей
исправление текста должно осуществляться более сложным образом. Вот
соответствующий алгоритм:</p>

<div class="list">
<ol>
<li>Заполним массивы dict_bad и dict_good (изначально пустые) данными из
словаря: для каждой взятой из словаря пары первый её член добавляется в
dict_bad, а второй&nbsp;— в dict_good; вдобавок к этому если оба члена
пары начинаются с прописной буквы или оба со строчной, то регистр первой
буквы каждого члена пары меняется на противоположный, и члены получившейся
пары точно так же добавляются в dict_bad и dict_good.

</li><li>Главный цикл. Для каждой пары соответствующих друг другу (т.е. имеющих
одинаковый индекс) элементов dict_bad и dict_good (обозначим эти элементы
bad и good) выполняем следующее:

<div class="letters">
<div class="letter">
а)&nbsp;сформируем оператор <nobr>поиска-замены</nobr> так, что выражением для
замены будет good, а регулярным выражением для поиска будет: bad, перед
которым добавлено подвыражение
<nobr>«(?&lt;![[:alpha:]'-])»,</nobr> а после bad&nbsp;—
подвыражение <nobr>«(?![[:alpha:]'-])».</nobr> Но если bad
начинается с «~», то этот «~» убирается и
подвыражение перед bad не добавляется. Аналогично, если bad заканчивается на
«~», то этот «~» убирается и подвыражение после bad
не добавляется;
</div>

<div class="letter">
б)&nbsp;выполним сформированный оператор <nobr>поиска-замены</nobr>
применительно к исправляемому тексту.
</div>
</div>

</li></ol>
</div>

<p class="up">Алгоритм создания или дополнения словаря также претерпел
изменения. Он приведён в следующем разделе.</p>

<h2><a name="n8">Окончательный алгоритм создания или&nbsp;дополнения
словаря</a></h2>

<div class="list" style="padding-top: 1em">
<p>Первые 5 пунктов&nbsp;— такие же, как в предыдущем варианте этого
алгоритма. Далее идут следующие пункты.</p>

<ol start="6">
<li>Заполним массивы dict_bad и dict_good (изначально пустые) данными из
словаря: для каждой взятой из словаря пары первый её член добавляется в
dict_bad, а второй&nbsp;— в dict_good; вдобавок к этому если оба члена
пары начинаются с прописной буквы или оба со строчной, то регистр первой
буквы каждого члена пары меняется на противоположный и члены получившейся
пары точно так же добавляются в dict_bad и dict_good.

</li><li>Заполним множество bad_words и массив bad_expr (изначально пустые), а
также дополним множество good_words. Для всего этого выполняем следующие
действия с каждой парой соответствующих друг другу (т.е. имеющих одинаковый
индекс) элементов dict_bad и dict_good:

<div class="letters">
<div class="letter">
a)&nbsp;если первый член пары&nbsp;— просто слово (не выражение), то при
условии, что это слово достаточной длины, добавляем его в bad_words (если
его там нет).
</div>

<div class="up">
Иначе (первый член пары&nbsp;— выражение) создаём на его основе
регулярное выражение (оно нужно, чтобы впоследствии можно было проверять,
описывается ли некоторое слово исходным выражением) путём следующих
изменений:
<ul class="mini-ul">
<li>если оно не начинается с «~», добавляем в начале
«^»;
</li><li>если оно не заканчивается на «~», добавляем в конце
«$»;
</li><li>если оно начинается на «~», удаляем этот «~»;
</li><li>если оно заканчивается на «~», удаляем этот «~».
</li></ul>
</div>

<div class="up">
Сформированное регулярное выражение добавляем в bad_expr. Замечу, что нет
требования, чтобы исходное выражение было достаточной длины (так как
выражение может описывать слова большей длины, чем длина его самого);
</div>

<div class="letter">
б)&nbsp;если оба члена пары&nbsp;— просто слова (а не выражения), то
считаем второй член пары допустимым словом и, если его длина достаточна,
помещаем его в good_words (если его там нет). Одного лишь факта, что второй
член пары подходит под определение слова, ещё недостаточно для утверждения,
что это допустимое слово. Это может быть часть слова, например, в паре
<nobr>«безшумн~ -&gt;</nobr> бесшумн». Поэтому и нужна проверка
обоих членов пары.
</div>
</div>

<div class="up">
Полученное множество bad_words будет обладать тем свойством, что слова в нём
не повторяются, являются неправильными и для них в словаре уже содержится
информация о том, как они должны быть исправлены. Полученный массив bad_expr
будет обладать тем свойством, что слова, соответствующие находящимся в нём
регулярным выражениям, являются неправильными и для них в словаре уже
содержится информация о том, как они должны быть исправлены. Множество
good_words после дополнения <nobr>по-прежнему</nobr> будет обладать
свойствами, упомянутыми в п.&nbsp;4.
</div>

</li><li>Главный цикл. Для каждого слова из source, кроме пустых слов в начале и
конце, выполняем:

<div class="letters">
<div class="letter">
а)&nbsp;если длина слова меньше минимальной&nbsp;— на этом его обработка
завершается;
</div>

<div class="letter">
б)&nbsp;если оно есть в good_words&nbsp;— значит, это допустимое слово,
на этом его обработка завершается;
</div>

<div class="letter">
в)&nbsp;если оно есть в bad_words либо подходит к <nobr>какому-либо</nobr>
выражению из bad_expr&nbsp;— значит, в словаре уже есть пара для
исправления этого слова, на этом его обработка завершается;
</div>

<div class="letter">
г)&nbsp;берём контекст текущего слова&nbsp;— слова слева и справа от
него&nbsp;— и составляем из них ключ (строку из этих двух слов,
разделённых запятой). Если в хеше by_context нет элемента с таким ключом,
значит, в отредактированном тексте нет ни одного слова достаточной длины с
таким контекстом, и на этом обработка текущего слова завершается;
</div>

<div class="letter">
д)&nbsp;внутренний цикл. Для каждого слова из массива, соответствующего
вышеуказанному ключу в хеше by_context (обозначим это слово j, а текущее
слово главного цикла&nbsp;— w), выполняем:
<ul>
<li>если j отличается от w только регистром, то на этом обработка j
завершается;

</li><li>если j не может быть исправлением w, то на этом обработка j завершается;

</li><li>если пара <nobr>w -&gt;</nobr> j есть в множестве bad_pairs (там
хранятся отвергнутые пользователем пары, изначально оно пусто), то на этом
обработка j завершается;

</li><li>предъявляем пользователю пару <nobr>w -&gt;</nobr> j. Если он подтвердил
её, то добавляем её в словарь, добавляем w в bad_words (а если оба слова
пары начинаются с букв одного регистра, то дополнительно добавляем в
bad_words первое слово с изменённым регистром первой буквы), и внутренний
цикл прерывается. Если же пользователь отверг пару, то добавляем её в
множество bad_pairs (а если оба слова пары начинаются с букв одного
регистра, то добавляем и пару, где у каждого слова регистр первой буквы
изменён на противоположный), и на этом обработка j завершается.
</li></ul>
</div>
</div>

</li></ol>
</div>

<p class="up">Рассмотрим работу алгоритма на простом примере.</p>

<p class="up">Исходный текст:<br>
Цена вполне соответсвует его качетсву.</p>

<p class="up">Отредактированный текст:<br>
Цена вполне соответствует его качеству.</p>

<p class="up">Исходный словарь:<br>
<nobr>воообще -&gt;</nobr> вообще, <nobr>соответсв~ -&gt;</nobr> соответств,
<nobr>вс(ё|е)таки -&gt;</nobr> <nobr>вс$1-таки.</nobr></p>

<p class="up">В каждом из нижеприведённых пунктов показывается, что
получится в результате выполнения соответствующего пункта алгоритма.</p>

<div class="list">
<ol>
<li>Массив source будет следующим: «», «Цена»,
«вполне», «соответсвует», «его»,
«качетсву», «».

</li><li>Массив edited будет следующим: «», «Цена»,
«вполне», «соответствует», «его»,
«качеству», «».

</li><li>Множество temp будет содержать элементы «,Цена,вполне»,
«Цена,вполне,соответствует»,
«вполне,соответствует,его», «его,качеству,». Элемент
«соответствует,его,качеству» не будет добавлен к множеству, так
как у него длина второго слова не является достаточной.

<div class="up">
Хеш by_context и дополнительные массивы будут следующими:
</div>

<div align="center">
<table border="1" cellpadding="5" class="c">
<caption align="bottom">Таблица&nbsp;2</caption>
<tbody><tr align="center">
<th>Ключ</th>
<th>Значение</th>
</tr>
<tr align="center">
<td>«,вполне»</td>
<td>Ссылка на&nbsp;массив из&nbsp;одного элемента «Цена»</td>
</tr>
<tr align="center">
<td>«Цена,соответствует»</td>
<td>—/—&nbsp;«вполне»</td>
</tr>
<tr align="center">
<td>«вполне,его»</td>
<td>—/—&nbsp;«соответствует»</td>
</tr>
<tr align="center">
<td>«его,»</td>
<td>—/—&nbsp;«качеству»</td>
</tr>
</tbody></table>
</div>

</li><li>Множество good_words будет содержать слова «Цена»,
«вполне», «соответствует», «качеству».

</li><li>Так как словарь есть, к п.&nbsp;8 не переходим.

</li><li>Массивы dict_bad и dict_good будут следующими:

<div class="up" align="center">
<table border="1" cellpadding="5" class="c">
<caption align="bottom">Таблица&nbsp;3</caption>
<tbody><tr align="center">
<th>Индекс</th>
<th>dict_bad</th>
<th>dict_good</th>
</tr>
<tr align="center">
<td>0</td>
<td>воообще</td>
<td>вообще</td>
</tr>
<tr align="center">
<td>1</td>
<td>Воообще</td>
<td>Вообще</td>
</tr>
<tr align="center">
<td>2</td>
<td>соответсв~</td>
<td>соответств</td>
</tr>
<tr align="center">
<td>3</td>
<td>Соответсв~</td>
<td>Соответств</td>
</tr>
<tr align="center">
<td>4</td>
<td>вс(ё|е)таки</td>
<td><nobr>вс$1-таки</nobr></td>
</tr>
<tr align="center">
<td>5</td>
<td>Вс(ё|е)таки</td>
<td><nobr>Вс$1-таки</nobr></td>
</tr>
</tbody></table>
</div>

</li><li>Рассмотрим обработку каждой пары из dict_bad и dict_good:
<ul>
<li>«воообще» и «вообще»: первый член
пары&nbsp;— «воообще»&nbsp;— просто слово; оно
достаточной длины; в bad_words его нет; добавляем его в bad_words. Оба члена
пары&nbsp;— просто слова; длина второго члена пары&nbsp;—
«вообще»&nbsp;— достаточна; в good_words его нет; добавляем
его в good_words;

</li><li>«Воообще» и «Вообще»: первый член
пары&nbsp;— «Воообще»&nbsp;— просто слово; оно
достаточной длины; в bad_words его нет; добавляем его в bad_words. Оба члена
пары&nbsp;— просто слова; длина второго члена пары&nbsp;—
«Вообще»&nbsp;— достаточна; в good_words его нет; добавляем
его в good_words;

</li><li>«соответсв~» и «соответств»: первый член
пары&nbsp;— «соответсв~»&nbsp;— выражение; создаём на
его основе регулярное выражение «^соответсв», которое добавляем
в bad_expr. Неверно, что оба члена пары&nbsp;— просто слова; на этом
обработка пары заканчивается;

</li><li>«Соответсв~» и «Соответств»: первый член
пары&nbsp;— «Соответсв~»&nbsp;— выражение; создаём на
его основе регулярное выражение «^Соответсв», которое добавляем
в bad_expr. Неверно, что оба члена пары&nbsp;— просто слова; на этом
обработка пары заканчивается;

</li><li>«вс(ё|е)таки» и <nobr>«вс$1-таки»:</nobr> первый
член пары&nbsp;— «вс(ё|е)таки»&nbsp;— выражение;
создаём на его основе регулярное выражение «^вс(ё|е)таки$»,
которое добавляем в bad_expr. Неверно, что оба члена пары&nbsp;— просто
слова; на этом обработка пары заканчивается;

</li><li>«Вс(ё|е)таки» и <nobr>«Вс$1-таки»:</nobr> первый
член пары&nbsp;— «Вс(ё|е)таки»&nbsp;— выражение;
создаём на его основе регулярное выражение «^Вс(ё|е)таки$»,
которое добавляем в bad_expr. Неверно, что оба члена пары&nbsp;— просто
слова; на этом обработка пары заканчивается.
</li></ul>

<div class="up">
В итоге множество bad_words будет содержать слова «воообще»,
«Воообще»; массив bad_expr будет содержать выражения
«^соответсв», «^Соответсв»,
«^вс(ё|е)таки$», «^Вс(ё|е)таки$»; множество
good_words будет содержать слова «Цена», «вполне»,
«соответствует», «качеству», «вообще»,
«Вообще».
</div>

</li><li>Рассмотрим обработку каждого слова из source, кроме пустых слов в начале
и конце:
<ul>
<li>«Цена»: длина слова не меньше минимальной; оно есть в
good_words, на этом его обработка завершается;

</li><li>«вполне»: длина слова не меньше минимальной; оно есть в
good_words, на этом его обработка завершается;

</li><li>«соответсвует»: длина слова не меньше минимальной; его нет в
good_words; его нет в bad_words, но оно подходит к выражению
«^соответсв» из bad_expr, на этом его обработка завершается;

</li><li>«его»: длина слова меньше минимальной, на этом его обработка
завершается;

</li><li>«качетсву»: длина слова не меньше минимальной; его нет в
good_words; его нет в bad_words, и оно не подходит ни к какому выражению из
bad_expr; ключ, составленный из слов слева и справа от него, будет
«его,»; в хеше by_context есть элемент с таким ключом, ему
соответствует массив из одного слова «качеству»; оно отличается
от «качетсву» не только регистром; оно может быть исправлением
слова «качетсву»; пары <nobr>«качетсву -&gt;</nobr>
качеству» нет в множестве bad_pairs; предъявляем её пользователю;
допустим, он подтвердил её; добавляем её в словарь, добавляем
«качетсву» в bad_words; так как оба слова пары начинаются с букв
одного регистра, то дополнительно добавляем в bad_words слово
«Качетсву»; на этом обработка слова «качетсву»
завершается.
</li></ul>

</li></ol>
</div>

<p class="up">В итоге словарь станет таким: <nobr>воообще -&gt;</nobr>
вообще, <nobr>соответсв~ -&gt;</nobr> соответств, <nobr>вс(ё|е)таки
-&gt;</nobr> <nobr>вс$1-таки,</nobr> <nobr>качетсву -&gt;</nobr>
качеству.</p>

<h2><a name="n9">Окончательная программа. Руководство пользователя</a></h2>

<p>Текст окончательной версии программы, подробно прокомментированный,
содержится в файле autocorr.pl, который вы можете найти в приложении к
данной статье. Программа написана на Perl (я использовал ActivePerl
5.8.6.811 для Windows&nbsp;— <a href="http://www.activestate.com/ActivePerl/">http://www.ActiveState.com/ActivePerl/</a>).</p>

<p>К программе также прилагается пример файла со словарём (default.dic), где
содержится ряд используемых мной замен. Если они вам подходят, то можете
пользоваться; конечно, можете и изменить этот словарь&nbsp;—
<nobr>что-то</nobr> убрать, <nobr>что-то</nobr> добавить.</p>

<p class="up">Итак, как же работать с программой. При её запуске нужно
указать в командной строке соответствующие аргументы. Первый из них
определяет режим работы программы и может быть одним из двух:</p>
<ul class="mini-ul">
<li>«/a»&nbsp;— дополнение словаря (если его нет, он
создаётся). Чтобы легче было запомнить, что «a» соответствует
дополнению, укажу, что это первая буква английского слова
«append»&nbsp;— «дополнять»;
</li><li>«/c»&nbsp;— исправление текста
(«c»&nbsp;— первая буква слова
«correct»&nbsp;— «исправлять»).
</li></ul>

<p class="up">После «/a» указываются следующие аргументы:</p>
<ul class="mini-ul">
<li>имя файла с исходным текстом;
</li><li>имя файла с отредактированным текстом;
</li><li>имя файла со словарём.
</li></ul>

<p class="up">После «/c» указываются:</p>
<ul class="mini-ul">
<li>имя файла с исходным текстом;
</li><li>имя файла, куда надо записать исправленный текст (может совпадать с
именем файла с исходным текстом, тогда он будет перезаписан);
</li><li>имя файла со словарём.
</li></ul>

<p class="up">Если программа запущена без аргументов либо с неверными
аргументами, то она выведет краткую справку по синтаксису её вызова (это
можно использовать, чтобы вспомнить, какие аргументы и в каком порядке надо
указывать: просто запускаем программу без аргументов и читаем выведенную
справку).</p>

<p>При нормальном завершении программы код выхода будет нулевым, а при
ошибке&nbsp;— нет.</p>

<p>Все файлы, обрабатываемые программой (тексты, словарь), должны быть в
кодировке <nobr>Windows-1251.</nobr></p>

<p class="up">Когда программа работает в режиме дополнения словаря, она
выводит пары слов, которые могут быть добавлены в словарь, и для каждой пары
ждёт решения пользователя. Если пара действительно должна быть добавлена (то
есть соответствующая замена всегда должна выполняться)&nbsp;— надо
нажать «y» и затем Enter; иначе&nbsp;— «n» и
Enter. На рис.&nbsp;1 показано, как выглядит экран при работе программы в
этом режиме.</p>

<div align="center">
<table>
<caption align="bottom">Рис.&nbsp;1</caption>
<tbody><tr><td><img src="./Без ошибок и опечаток_files/1.gif" width="628" height="178" alt=""></td></tr>
</tbody></table>
</div>

<p class="up">После того как программа окончила работу, можно в текстовом
редакторе просмотреть дополненный словарь (добавленные пары находятся в его
конце и отделены пустой строкой от предшествующего содержимого) и, если
нужно, добавить комментарии, внести изменения. Например, в словарь была
добавлена пара <nobr>«телеофна -&gt;</nobr> телефона», а можно
изменить её на <nobr>«телеофн~ -&gt;</nobr> телефон»&nbsp;—
тогда окончание ошибочного слова может быть любым, в результате больше
ошибок будет исправлено.</p>

<p class="up">Теперь рассмотрим работу программы в режиме исправления
текста. Она выводит информацию о том, какие замены сколько раз были
произведены (в виде «пара: количество замен»), а в
конце&nbsp;— общее количество произведённых замен, то есть исправленных
слов (рис.&nbsp;2).</p>

<div align="center">
<table>
<caption align="bottom">Рис.&nbsp;2</caption>
<tbody><tr><td><img src="./Без ошибок и опечаток_files/2.gif" width="628" height="196" alt=""></td></tr>
</tbody></table>
</div>

<p class="up">Если эта информация важна для вас, но не умещается на экране
или же вы просто хотите иметь возможность просмотреть её в любое удобное
время, то можно перенаправить вывод программы в файл. Для этого при запуске
программы добавьте в конце командной строки символ «&gt;» и
сразу за ним&nbsp;— имя этого файла. А если вместо «&gt;»
указать «&gt;&gt;», то информация будет дописана к этому
файлу&nbsp;— это может быть полезным, если программа запускается
несколько раз и надо сохранить всю статистику в одном файле.</p>

<p>Замечу, что программу нельзя использовать для исправления текста, в
котором есть переносы слов: конец перенесённого слова может быть принят
программой за неправильное слово и заменён, что лишь навредит; также, если
неправильное слово разбито переносом, то программа его «не
узнает» и, соответственно, не исправит.</p>

<p class="up">О формате файла со словарём. Это обычный текстовый файл в
кодировке <nobr>Windows-1251,</nobr> его имя и расширение могут быть
произвольными (я использую расширение «dic», от
«dictionary»&nbsp;— «словарь»). Каждая строка
этого файла может состоять из трёх частей, расположенных в следующем
порядке:</p>
<ul class="mini-ul">
<li>пара для поиска и замены в виде «что <nobr>заменять -&gt;</nobr> на
что заменять»;
</li><li>последовательность пробелов и/или табуляций;
</li><li>комментарий (начинается с символа «#» и продолжается до
конца строки).
</li></ul>

<p>Каждая из этих частей является необязательной. Таким образом, в файл со
словарём могут быть помещены, например, пустые строки (скажем, чтобы
отделять друг от друга <nobr>какие-то</nobr> группы пар) и строки, состоящие
только из комментариев. Вы можете увидеть это в прилагаемом файле
default.dic.</p>

<h2><a name="n10">Регулярные выражения</a></h2>

<p>Кратко опишу основные конструкции, применяемые в регулярных выражениях
Perl, показывая на примерах их использование в парах словаря.</p>

<h3><a name="n10_1">1. Класс символов</a></h3>

<p>Это конструкция вида «[abc]» (то есть заключённая в
квадратные скобки последовательность символов). Она соответствует любому из
этих символов.</p>

<p>Можно указывать диапазоны: например, <nobr>«[а-гп]»</nobr>
эквивалентно «[абвгп]». То есть символ
<nobr>«-»</nobr> используется в специальных целях&nbsp;—
для обозначения диапазона между символами слева и справа от него. Чтобы
<nobr>«-»</nobr> интерпретировался как обычный символ, надо
поместить его в самом начале или конце класса.</p>

<p>Замечу, что в моей программе используется кодировка
<nobr>Windows-1251,</nobr> поэтому диапазон
<nobr>«а—я»</nobr> не содержит букву «ё» (так как
её код в этой кодировке не входит в диапазон от кода буквы «а» до
кода буквы «я»). Точно так же и диапазон
<nobr>«А—Я»</nobr> не содержит «Ё».</p>

<p>Символ «^» сразу после открывающей квадратной скобки означает
отрицание. Например, «[^аб]»&nbsp;— любой символ, кроме
«а» и «б».</p>

<p class="up">Пример использования. Пусть надо исправлять ошибочные
написания «лудше» и «лутше» на правильное
«лучше». Тогда вместо двух пар:<br>
<br>
<nobr>лудше -&gt;</nobr> лучше<br>
<nobr>лутше -&gt;</nobr> лучше<br>
<br>
можно использовать одну, первый член которой будет регулярным выражением,
соответствующим словам «лудше» и «лутше». Это
выражение может быть таким: «лу[дт]ше». В итоге получится такая
пара:<br>
<br>
<nobr>лу[дт]ше -&gt;</nobr> лучше.</p>

<h3><a name="n10_2">2. Альтернатива</a></h3>

<p>Это конструкция вида «(A|B|C)», то есть заключённая в скобки
последовательность подвыражений, разделённых символом «|».
Подвыражение может быть, в частности, пустым. Такая конструкция
соответствует участку текста, если ему соответствует <nobr>какое-либо</nobr>
из указанных подвыражений (они перебираются слева направо).</p>

<p class="up">Пример использования. Пусть надо исправлять ошибочные
написания «отсутсвие» и «отсуствие» на правильное
«отсутствие». Тогда вместо двух пар:<br>
<br>
<nobr>отсутсвие -&gt;</nobr> отсутствие<br>
<nobr>отсуствие -&gt;</nobr> отсутствие<br>
<br>
можно использовать одну, первый член которой будет регулярным выражением,
соответствующим словам «отсутсвие» и «отсуствие».
Это выражение может быть таким: «отсу(тс|ст)вие». В итоге
получится такая пара:<br>
<br>
<nobr>отсу(тс|ст)вие -&gt;</nobr> отсутствие.</p>

<p class="up">Между прочим, если написать так:<br>
<br>
<nobr>(отсутсвие|отсуствие) -&gt;</nobr> отсутствие,<br>
<br>
то, хотя на первый взгляд это то же самое, исправление не будет выполняться,
если ошибочное слово начинается с прописной буквы&nbsp;— потому что,
как уже упоминалось выше, независимость от регистра первой буквы
обеспечивается лишь в случае, когда оба члена пары начинаются с буквы одного
регистра, а здесь первый член пары начинается с «(», а не с
буквы.</p>

<h3><a name="n10_3">3. Указание количества повторов</a></h3>

<p>В табл.&nbsp;4 приведены конструкции, используемые для указания
количества повторов находящегося перед ними символа, или класса символов,
или заключённого в скобки подвыражения.</p>


<div align="center">
<table border="1" cellpadding="5" class="c">
<caption align="bottom">Таблица&nbsp;4</caption>
<tbody><tr align="center">
<th>Конструкция</th>
<th>Количество повторов</th>
</tr>
<tr align="center">
<td>*</td>
<td>0 или&nbsp;более</td>
</tr>
<tr align="center">
<td>+</td>
<td>1 или&nbsp;более</td>
</tr>
<tr align="center">
<td>?</td>
<td>0 или&nbsp;1</td>
</tr>
<tr align="center">
<td>{n}</td>
<td>n</td>
</tr>
<tr align="center">
<td>{n,}</td>
<td>n или&nbsp;более</td>
</tr>
<tr align="center">
<td>{n,m}</td>
<td>от&nbsp;n до&nbsp;m включительно</td>
</tr>
</tbody></table>
</div>

<p>Пример использования. Пусть надо исправлять
<nobr>«видео-плеер»</nobr> и
<nobr>«видео-плейер»</nobr> на «видеоплеер». Тогда
вместо двух пар:<br>
<br>
<nobr>видео-плеер -&gt;</nobr> видеоплеер<br>
<nobr>видео-плейер -&gt;</nobr> видеоплеер<br>
<br>
можно использовать одну, первый член которой будет регулярным выражением,
соответствующим словам <nobr>«видео-плеер»</nobr> и
<nobr>«видео-плейер».</nobr> Это выражение может быть таким:
<nobr>«видео-плей?ер»</nobr> («?» после
«й» указывает на количество повторов 0 или 1, то есть эта буква
может быть или не быть). В итоге получится такая пара:<br>
<br>
<nobr>видео-плей?ер -&gt;</nobr> видеоплеер.</p>

<h3><a name="n10_4">4. Условия</a></h3>

<p>Это конструкции следующего вида:<br>
(?&lt;=A)&nbsp;— «то, что слева, соответствует подвыражению
A»;<br>
(?&lt;!A)&nbsp;— «то, что слева, не соответствует подвыражению
A»;<br>
(?=A)&nbsp;— «то, что справа, соответствует подвыражению
A»;<br>
(?!A)&nbsp;— «то, что справа, не соответствует подвыражению
A».</p>

<p class="up">Пример использования. Допустим, слова
«пиктограмма», «пиктограммы» и т.д. могут быть
записаны с ошибкой&nbsp;— с одной «м» вместо двух, и надо
создать пару для исправления этого. Тут нельзя просто записать:<br>
<br>
<nobr>пиктограм~ -&gt;</nobr> пиктограмм,<br>
<br>
так как такая пара хотя и исправит указанные ошибки, но при этом будет
добавлять лишнюю «м» в случае правильного написания. Выходом из
такой ситуации будет применение условия, что после «пиктограм»
не следует «м». То есть пара будет такой:<br>
<br>
<nobr>пиктограм(?!м)~ -&gt;</nobr> пиктограмм.</p>

<h3><a name="n10_5">5. Подстановка</a></h3>

<p>Если регулярное выражение содержит подвыражения, заключённые в скобки, то
при его успешном сопоставлении некоторому участку текста происходит
запоминание во встроенных переменных $1, $2 и т.д. фрагментов этого текста,
соответствующих этим подвыражениям. Участок текста, соответствующий всему
выражению, запоминается в переменной $&amp;. Выражение для замены, в свою
очередь, может содержать «$1», «$2» и т.д.,
«$&amp;», и при выполнении замены будет произведена подстановка
значений этих переменных.</p>

<p class="up">Пример использования. Допустим, слово «выбранный»
и его изменения по числам, родам, падежам могут быть записаны с
ошибкой&nbsp;— с одной «н» вместо двух, и надо создать пару
для исправления этого. Если по аналогии с предыдущим примером использовать
пару <nobr>«выбран(?!н)~ -&gt;</nobr> выбранн», это не подойдёт,
так как хотя ошибочные слова и будут исправлены, но будет добавляться лишняя
«н» в слова «выбран»,
«выбрана»…</p>

<p>Пойдём другим путём&nbsp;— перечислим все возможные окончания
исправляемого слова с помощью конструкции «альтернатива»:
«(ый|ого|ому|ым|ом|ая|ой|ую|ое|ые|ых|ыми)». Данная конструкция
является подвыражением в скобках, и больше никаких подвыражений в скобках мы
не используем; таким образом, окончание исправляемого слова будет
запоминаться в переменной $1. А чтобы в исправленном слове было то же
окончание, что и в исходном, ставим во втором члене пары (то есть в
выражении для замены) «$1» вместо этого окончания. В итоге
получится такая пара:<br>
<br>
<nobr>выбран(ый|ого|ому|ым|ом|ая|ой|ую|ое|ые|ых|ыми) -&gt;</nobr>
выбранн$1.</p>

<p class="up">Подробнее узнать о регулярных выражениях Perl можно в
документации к Perl, а также на русском языке&nbsp;— например, по
следующим ссылкам:<br>
<br>
<a href="http://www.opennet.ru/docs/RUS/perlre_man/">http://www.opennet.ru/docs/RUS/perlre_man/</a><br>
<a href="http://www.pereplet.ru/nauka/perl/regex.shtml">http://www.pereplet.ru/nauka/perl/regex.shtml</a></p>

<p class="up">В завершение рассмотрим более сложный пример с использованием
различных вышеописанных конструкций. Пусть надо исправлять ошибочные
написания слов, начинающихся с «аккумулятор», если ошибки
заключаются в следующем: вместо двух «к» может быть одно, вместо
первой «у» может быть «о» или «а»,
вместо одного «л» может быть два; могут быть и сразу несколько
из этих ошибок.</p>

<p>Попробуем составить выражение, соответствующее ошибочным написаниям.
Вместо двух «к» может быть одно&nbsp;— то есть может быть
либо одно, либо два «к», это может быть записано как
«кк?». Вместо первой «у» может быть «о»
или «а»&nbsp;— то есть эта буква может быть одной из
«о», «а», «у», это может быть записано
как «[оау]». Вместо одного «л» может быть
два&nbsp;— то есть может быть либо одно, либо два «л», это
может быть записано как «лл?». Итого, все ошибочные написания
начала слова могут быть описаны выражением «акк?[оау]мулл?ятор».
Так как окончание слова может быть любым, добавляем «~» в конце:
«акк?[оау]мулл?ятор~».</p>

<p>Но это выражение также будет соответствовать и правильному написанию,
поэтому правильные слова, начинающиеся на «аккумулятор», тоже
будут «исправляться», хотя и не изменятся <nobr>из-за</nobr>
этого. Вроде бы ничего плохого, но это изменит статистику замен, выводимую
программой (сколько каких замен было произведено). Естественно, что в
статистике имеет смысл отражать только действительные исправления
ошибок.</p>

<p>Чтобы выражение перестало соответствовать правильному написанию, добавим
в конце (но перед «~», поскольку «~» должно быть в
самом конце) соответствующее условие. Получится выражение
«акк?[оау]мулл?ятор(?&lt;![Аа]ккумулятор)~». В итоге будет такая
пара:<br>
<br>
<nobr>акк?[оау]мулл?ятор(?&lt;![Аа]ккумулятор)~ -&gt;</nobr> аккумулятор.</p>

<p class="up">Почему в условии написано «[Аа]ккумулятор», а не
просто «аккумулятор»? Дело в том, что оба члена пары начинаются
с буквы в одном регистре, а значит, исправление текста будет происходить
так, как если бы в словаре вместо этой пары было две: у одной оба члена
начинаются со строчной буквы, а у другой&nbsp;— с прописной. То есть
первая буква исправляемого слова может быть и «а», и
«А», что и отражено в условии.</p>

<h2><a name="n11">Исправление ошибочного слитного и&nbsp;раздельного
написания</a></h2>

<p>В программе не предусмотрено, чтобы при дополнении словаря находились и
предъявлялись пользователю пары для исправления таких ошибок, как слитное
написание вместо раздельного, и наоборот (к слитному написанию я здесь, для
простоты классификации, отношу и написание через дефис). Однако такие пары
могут быть добавлены в словарь вручную, например:<br>
<br>
<nobr>небыло -&gt;</nobr> не было<br>
<nobr>несчем -&gt;</nobr> не с чем<br>
<nobr>в замен -&gt;</nobr> взамен<br>
<nobr>во первых -&gt;</nobr> <nobr>во-первых</nobr></p>

<p class="up">При этом есть одно обстоятельство, относящееся к случаю, когда
ошибочное раздельное написание заменяется на слитное. Для примера возьмём
пару «в <nobr>замен -&gt;</nobr> взамен». Соответствующая замена
будет осуществляться, только если в обрабатываемом тексте между
«в» и «замен» находится строго один пробел.</p>

<p>А если слова в тексте могут быть разделены несколькими пробелами и (или)
табуляциями? Как сделать, чтобы и в этом случае происходила замена? Вспомним
о регулярных выражениях. В первом члене пары вместо пробела запишем
выражение «[&nbsp;\t]+» («\t»&nbsp;—
обозначение табуляции). Получится пара <nobr>«в[&nbsp;\t]+замен
-&gt;</nobr> взамен». Теперь замена произойдёт, если между
«в» и «замен» в тексте находится 1 или более
пробелов и (или) табуляций.</p>

<p>Если же слова в тексте всегда разделяются либо пробелом, либо переводом
строки, то аналогичным образом используем выражение «[&nbsp;\n]»
(«\n»&nbsp;— обозначение перевода строки), получится пара
<nobr>«в[&nbsp;\n]замен -&gt;</nobr> взамен». А если слова могут
разделяться либо последовательностью пробелов и (или) табуляций, либо
переводом строки, используем выражение
«([&nbsp;\t]+|\n)»&nbsp;— получится пара
<nobr>«в([&nbsp;\t]+|\n)замен -&gt;</nobr> взамен».</p>

<h2><a name="n12">«Почти хорошие» ошибки</a></h2>

<p>Бывают такие ошибки (назовём их «почти хорошими»), которые не
являются «хорошими», но их исправление с помощью автозамены лишь
в редких случаях приведёт к появлению новых ошибок, а чаще всего будут
исправлены настоящие ошибки (это, конечно, зависит от количества и характера
ошибок в обрабатываемом тексте). Допустим, в тексте часто встречается
ошибочное написание «что бы» вместо «чтобы», и редко
встречается такое сочетание «что бы», которое является
правильным; тогда автозамена «что <nobr>бы -&gt;</nobr> чтобы»
как раз и приведёт к вышеуказанным последствиям.</p>

<p>Если не использовать автозамену для исправления «почти
хороших» ошибок, то придётся исправлять их вручную, зато не
возникнут новые ошибки. А если использовать, то не придётся исправлять их
вручную, зато могут возникнуть новые ошибки, и есть риск не заметить и не
исправить их при последующем просмотре текста.</p>

<p>Можно сделать так. Пусть при автоисправлении таких ошибок добавляется
специальный символ в том месте, где произошло исправление. Этот символ не
должен встречаться в тексте и должен выглядеть так, чтобы привлекать
внимание при просмотре текста. Я использую символ с кодом 30&nbsp;— в
Dos Navigator, где я редактирую тексты, он отображается в виде треугольника.
<nobr>Из-за</nobr> возможных проблем с его отображением в этой статье, я
буду вместо него использовать символ «^». Вы можете выбрать и
другой символ (только не «#», потому что он в строке словаря
означает начало комментария). Таким образом, для исправления ошибки,
взятой в качестве примера, в словарь должна быть добавлена пара «что
<nobr>бы -&gt;</nobr> что^бы».</p>

<p>Что дальше? После запуска программы, при проверке обработанного текста
надо обращать внимание на появления этого символа. Встретили
«что^бы»&nbsp;— значит, тут была произведена автозамена
«что <nobr>бы -&gt;</nobr> что^бы», и надо подумать,
действительно ли в результате оказалась исправлена ошибка. Если нет, то надо
исправить обратно: «что^бы» на «что^ бы»
(«^» убирать не обязательно). А когда весь текст проверен,
остаётся только автоматически удалить из него все символы «^»
(например, просто в текстовом редакторе заменить «^» на пустую
строку).</p>

<h2><a name="n13">Разное</a></h2>

<p>В словарь можно добавлять и пары вида «несколько <nobr>слов
-&gt;</nobr> несколько слов», например:<br>
<br>
<nobr>не разу -&gt;</nobr> ни разу.</p>

<p class="up">При этом если в обрабатываемом тексте слова разделяются не
всегда в точности одним пробелом, то, чтобы замена выполнялась, в первом
члене пары нужно вместо пробелов использовать соответствующие регулярные
выражения (см. «<a href="http://ivr.webzone.ru/articles/autocorr/index.htm#n11">Исправление ошибочного слитного и
раздельного написания</a>»).</p>

<div align="center">* * *</div>

<p>Чтобы обеспечить написание некоторого слова с прописной буквы, удобно
использовать такую пару:<br>
<br>
<nobr>слово -&gt;</nobr> \u$&amp;.</p>

<p class="up">При выполнении замены вместо «$&amp;» подставится
заменяемое слово, а «\u» означает «преобразовать в верхний
регистр следующий символ» (если он является буквой). Поэтому первая
буква слова и станет прописной.</p>

<p>Вместо <nobr>какого-то</nobr> конкретного слова может быть и регулярное
выражение, например:<br>
<br>
<nobr>москв(а|ы|е|у|ой) -&gt;</nobr> \u$&amp;.</p>

<div align="center">* * *</div>

<p>Чтобы заключить некоторое слово в кавычки, пропуская те его вхождения, где
оно уже в кавычках, можно использовать такую пару:<br>
<br>
<nobr>(?&lt;!")слово(?!") -&gt;</nobr> "$&amp;".</p>

<p class="up">Здесь «(?&lt;!")» и
«(?!")»&nbsp;— условия: соответственно «слева
от слова нет кавычки» и «справа от слова нет кавычки».</p>

<p>Заключать в кавычки можно и не только <nobr>какое-то</nobr> одно конкретное
слово, например:<br>
<br>
<nobr>(?&lt;!")Мир(а|у|ом|е|) ПК(?!") -&gt;</nobr>
"$&amp;".</p>

<div align="center">* * *</div>

<p>Если имеется набор некоторых текстов и набор соответствующих
отредактированных текстов и вы хотите использовать их для дополнения
словаря, то можно не запускать каждый раз программу для очередной пары
«исходный текст, отредактированный текст», а поступить проще.
Сформируем файл со склеенными исходными текстами (например, с помощью
команды copy) и файл со склеенными отредактированными текстами (которые
могут даже следовать в другом порядке, нежели исходные), после чего
используем эти два файла для дополнения словаря. Потребуется лишь один
запуск программы. Причём так можно делать, даже если не для каждого
исходного текста есть соответствующий ему отредактированный и наоборот.</p>

<div align="center">* * *</div>

<p>Программу можно использовать не только для исправления ошибок, но и
просто для замены одних слов на другие. Также можно применять её для анализа
текстов, используя тот факт, что она, будучи запущена в режиме исправления
ошибок, выводит статистику замен. Пусть, например, надо узнать, сколько раз
встречается в некотором тексте слово «Windows», а сколько раз
слово «Linux». Создаём словарь, где эти слова заменялись бы на
<nobr>что-то</nobr> (пусть сами на себя):<br>
<br>
<nobr>Windows -&gt;</nobr> $&amp;<br>
<nobr>Linux -&gt;</nobr> $&amp;<br>
<br>
Затем запускаем программу в режиме исправления ошибок для этого текста с этим
словарём (файл, куда будет записан исправленный текст, нам не понадобится,
поэтому вместо его имени указываем «nul») и смотрим на выведенную
статистику.</p>

<h2><a name="n14">Приложение</a></h2>

<div>
<a href="http://ivr.webzone.ru/articles/autocorr/files.zip">Скачать описанную программу и&nbsp;пример файла
со&nbsp;словарём (19&nbsp;КБ&nbsp;ZIP)</a>
</div>

<div class="g">
<table class="g1" width="100%" border="1">
<tbody><tr><td class="g1">
<a class="g2" href="http://ivr.webzone.ru/index.htm">Страница&nbsp;Ивана&nbsp;Рощина</a>&nbsp;&gt;
<a class="g2" href="http://ivr.webzone.ru/articles/index.htm">Статьи</a>&nbsp;&gt;
</td></tr>
</tbody></table>
</div>



</body></html>